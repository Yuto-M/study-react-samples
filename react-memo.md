## JSX内で{}を使用すればjsを使うことができる

- コンポーネント間で特定のstateを共有したいときは、親コンポーネントがstateを保持し、そのstateを子コンポーネントに渡してあげる形をとるのがよい。（トップダウン型データフローまたは単一方向データフローという）
https://ja.reactjs.org/docs/lifting-state-up.html
https://ja.reactjs.org/docs/state-and-lifecycle.html#the-data-flows-down

- props もしくは state から作りだす事のできるデータについては、おそらく state に保持すべきではないでしょう

- props.childrenを使用すると受け取った子要素を出力できる
https://ja.reactjs.org/docs/composition-vs-inheritance.html

## reactの設計方法
  - UIをコンポーネントの階層構造に落とし込む
    - markupとcssは最初に用意しておいたほうがいいと思う。renderメソッドに組み込むとき際、すんなりいくから。
  - 階層構造に落とし込んだら静的なバージョンを実装する
    - 静的なバージョンの場合はrenderメソッドのみ持つことになる
    - stateは使わずpropsを使って実装していく
    - シンプルなアプリならトップダウンで作ったほうが楽
    - 大規模なアプリならテストを書きながらボトムアップで作ったほうが楽
  - アプリに必要とされる状態を最小構成で作る
    - アプリで使用するデータを抜き出す
    - そのデータがstateになりうるか考える。下記に該当するものはstateにはならない。
      - 親から props を通じて与えられたデータか
      - 時間経過で変化しないままでいるデータか
      - コンポーネント内にある他の props や state を使って算出可能なデータか
  - stateをどこに配置させるか
```
その state を使って表示を行う、すべてのコンポーネントを確認する
共通の親コンポーネントを見つける（その階層構造の中で、ある state を必要としているすべてのコンポーネントの上位にある単一のコンポーネントのことです）
共通の親コンポーネントか、その階層構造でさらに上位の別のコンポーネントが state を持っているべきである
もし state を持つにふさわしいコンポーネントを見つけられなかった場合は、state を保持するためだけの新しいコンポーネントを作り、階層構造の中ですでに見つけておいた共通の親コンポーネントの上に配置する
```
 - 逆方向のデータフローを追加
   - つまりあるコンポーネントが親のstateを更新できるようにする

## renderでなにも表示させたくない時
下記のようにnullを返せばおｋ
```
render() {
  return (
    null
  );
}
```

## リストの項目にはkeyを含める
  - reactにどの要素が変化したかを教えるために必要
  - keyとして与えるものとして一意に識別できる識別子（id）などがベスト
    - 但し、インデックスはやめた方がよい
  - keyは基本的にmap呼び出しの中で設定する
  - keyは兄弟要素の中で一意